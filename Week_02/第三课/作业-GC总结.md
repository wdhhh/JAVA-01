## 一、压测分析

### 1.压测gateway.jar

sb 30并发50秒

| gc       | XMX  | YGC  | YGCAvg | YGCMin/Max | FGC  | FGCAvg | FGCMin/Max | Duration      | Pause Total | RPS    | remark                |
| -------- | ---- | ---- | ------ | ---------- | ---- | ------ | ---------- | ------------- | ----------- | ------ | --------------------- |
| Serial   | 512m | 38   | 6.58ms | 0/30ms     | 2    | 50ms   | 50/50ms    | 57s 299ms     | 350ms       | 3624.2 |                       |
|          | 1g   | 18   | 12.8ms | 0/30ms     | 2    | 55ms   | 30/80ms    | 55s 469ms     | 340ms       | 3427   |                       |
|          | 4g   | 4    | 6.25ms | 6/7.4ms    | 2    | 105ms  | 80/130ms   | 1m3s318ms     | 235ms       | 3691.5 | 为什么YGC单次耗时要快 |
| Parallel | 512m | 37   | 3.24ms | 0/20ms     | 2    | 35ms   | 20/50ms    | 57s 987ms     | 190ms       | 3374.5 |                       |
|          | 1g   | 18   | 1.67ms | 0/20ms     | 2    | 40ms   | 30/50ms    | 55s 33ms      | 110ms       | 3597.5 |                       |
|          | 4g   | 6    | 3.33ms | 0/20ms     | 2    | 40ms   | 30/50ms    | 52s 287ms     | 100ms       | 3561.5 |                       |
| CMS      | 512m | 38   | 5.79ms | 0/20ms     | 1    | 20ms   | 0/20ms     | 57s 846ms     | 240ms       | 3456.1 | 为什么吞吐量不如串行  |
|          | 1g   | 18   | 8.33ms | 0/30ms     | 1    | 10ms   | 0/10ms     | 54s 522ms     | 160ms       | 3383.8 |                       |
|          | 4g   | 10   | 16ms   | 0/60ms     | 1    | 120ms  | 0/120ms    | 58 sec 457 ms | 280ms       | 3463.1 |                       |
| G1       | 512m | 18   | 17.8ms | 0/30ms     | 2    | 20ms   | 0/20ms     | 1m6s237ms     | 360ms       | 3316.5 |                       |
|          | 1g   | 8    | 15ms   | 0/30ms     | 2    | 25ms   | 0/30ms     | 59s 282ms     | 170ms       | 2933.5 |                       |
|          | 4g   | 4    | 27.5ms | 0/80ms     | 2    | 20ms   | 0/20ms     | 1m 9s 17ms    | 190ms       | 3541.8 |                       |

疑问：

问题1  为什么串行GC，4G的平均单次YGC要比1G时的平均单次YGC要快很多？

1.分别查看GC日志：

4G（部分）：

```java
2021-01-19T22:00:46.507+0800: 32.291: [GC (Allocation Failure) 2021-01-19T22:00:46.507+0800: 32.291: [DefNew: 1118528K->3861K(1258304K), 0.0074359 secs] 1151209K->36542K(4054528K), 0.0075240 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:00:55.960+0800: 41.740: [GC (Allocation Failure) 2021-01-19T22:00:55.960+0800: 41.740: [DefNew: 1122389K->3286K(1258304K), 0.0065270 secs] 1155070K->35968K(4054528K), 0.0066247 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:01:07.022+0800: 52.805: [GC (Allocation Failure) 2021-01-19T22:01:07.022+0800: 52.805: [DefNew: 1121814K->3263K(1258304K), 0.0060816 secs] 1154496K->35945K(4054528K), 0.0061878 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:01:18.677+0800: 64.471: [GC (Allocation Failure) 2021-01-19T22:01:18.677+0800: 64.471: [DefNew: 1121791K->3278K(1258304K), 0.0055835 secs] 1154473K->35959K(4054528K), 0.0056806 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
```

1G（部分）：

```java
2021-01-19T22:02:05.864+0800: 1.134: [GC (Allocation Failure) 2021-01-19T22:02:05.864+0800: 1.134: [DefNew: 279616K->14881K(314560K), 0.0258393 secs] 279616K->14881K(1013632K), 0.0260449 secs] [Times: user=0.05 sys=0.00, real=0.03 secs] 
2021-01-19T22:02:05.895+0800: 1.165: [Full GC (Metadata GC Threshold) 2021-01-19T22:02:05.895+0800: 1.165: [Tenured: 0K->14694K(699072K), 0.0245114 secs] 25787K->14694K(1013632K), [Metaspace: 20509K->20509K(1067008K)], 0.0245757 secs] [Times: user=0.01 sys=0.02, real=0.03 secs] 
2021-01-19T22:02:07.551+0800: 2.822: [GC (Allocation Failure) 2021-01-19T22:02:07.551+0800: 2.822: [DefNew: 279616K->15933K(314560K), 0.0316358 secs] 294310K->30628K(1013632K), 0.0316974 secs] [Times: user=0.03 sys=0.03, real=0.03 secs] 
2021-01-19T22:02:12.876+0800: 8.150: [Full GC (Metadata GC Threshold) 2021-01-19T22:02:12.876+0800: 8.150: [Tenured: 14694K->27588K(699072K), 0.0728177 secs] 200427K->27588K(1013632K), [Metaspace: 33848K->33848K(1079296K)], 0.0728909 secs] [Times: user=0.08 sys=0.00, real=0.08 secs] 
2021-01-19T22:02:18.262+0800: 13.535: [GC (Allocation Failure) 2021-01-19T22:02:18.262+0800: 13.535: [DefNew: 279616K->3863K(314560K), 0.0059641 secs] 307204K->31452K(1013632K), 0.0060493 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
2021-01-19T22:02:20.782+0800: 16.056: [GC (Allocation Failure) 2021-01-19T22:02:20.782+0800: 16.056: [DefNew: 283479K->3322K(314560K), 0.0055749 secs] 311068K->30911K(1013632K), 0.0056644 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
2021-01-19T22:02:23.438+0800: 18.705: [GC (Allocation Failure) 2021-01-19T22:02:23.438+0800: 18.705: [DefNew: 282938K->3292K(314560K), 0.0048491 secs] 310527K->30881K(1013632K), 0.0049289 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:02:26.061+0800: 21.330: [GC (Allocation Failure) 2021-01-19T22:02:26.061+0800: 21.330: [DefNew: 282908K->3296K(314560K), 0.0051878 secs] 310497K->30885K(1013632K), 0.0052810 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:02:28.514+0800: 23.782: [GC (Allocation Failure) 2021-01-19T22:02:28.514+0800: 23.782: [DefNew: 282912K->3289K(314560K), 0.0047979 secs] 310501K->30878K(1013632K), 0.0048901 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:02:30.826+0800: 26.097: [GC (Allocation Failure) 2021-01-19T22:02:30.826+0800: 26.097: [DefNew: 282905K->3292K(314560K), 0.0047381 secs] 310494K->30881K(1013632K), 0.0048100 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:02:33.656+0800: 28.931: [GC (Allocation Failure) 2021-01-19T22:02:33.656+0800: 28.931: [DefNew: 282908K->3313K(314560K), 0.0054425 secs] 310497K->30902K(1013632K), 0.0055379 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
2021-01-19T22:02:36.703+0800: 31.978: [GC (Allocation Failure) 2021-01-19T22:02:36.703+0800: 31.978: [DefNew: 282929K->3312K(314560K), 0.0058323 secs] 310518K->30901K(1013632K), 0.0059342 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
2021-01-19T22:02:39.718+0800: 34.980: [GC (Allocation Failure) 2021-01-19T22:02:39.718+0800: 34.980: [DefNew: 282928K->3305K(314560K), 0.0057957 secs] 310517K->30894K(1013632K), 0.0058734 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:02:42.577+0800: 37.848: [GC (Allocation Failure) 2021-01-19T22:02:42.577+0800: 37.848: [DefNew: 282921K->3300K(314560K), 0.0060289 secs] 310510K->30889K(1013632K), 0.0061213 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 
2021-01-19T22:02:45.592+0800: 40.865: [GC (Allocation Failure) 2021-01-19T22:02:45.592+0800: 40.865: [DefNew: 282916K->3302K(314560K), 0.0056361 secs] 310505K->30891K(1013632K), 0.0057762 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
2021-01-19T22:02:48.575+0800: 43.838: [GC (Allocation Failure) 2021-01-19T22:02:48.575+0800: 43.838: [DefNew: 282918K->3343K(314560K), 0.0058683 secs] 310507K->30931K(1013632K), 0.0059556 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:02:51.603+0800: 46.871: [GC (Allocation Failure) 2021-01-19T22:02:51.603+0800: 46.871: [DefNew: 282959K->3330K(314560K), 0.0057608 secs] 310547K->30919K(1013632K), 0.0058577 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2021-01-19T22:02:54.686+0800: 49.957: [GC (Allocation Failure) 2021-01-19T22:02:54.686+0800: 49.957: [DefNew: 282946K->3306K(314560K), 0.0056077 secs] 310535K->30895K(1013632K), 0.0057110 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
2021-01-19T22:02:58.199+0800: 53.473: [GC (Allocation Failure) 2021-01-19T22:02:58.199+0800: 53.473: [DefNew: 282922K->3306K(314560K), 0.0061145 secs] 310511K->30895K(1013632K), 0.0062781 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
2021-01-19T22:03:01.333+0800: 56.604: [GC (Allocation Failure) 2021-01-19T22:03:01.333+0800: 56.604: [DefNew: 282922K->67K(314560K), 0.0068666 secs] 310511K->30891K(1013632K), 0.0069324 secs] [Times: user=0.02 sys=0.00, real=0.02 secs] 
```

1.是否跟每次GC清理的内存数量有关？

4G的YGC每次大概清理1,110,000k左右的数据，耗时5-7ms。1G的YGC，两次耗时30ms的GC，每次大概清理250,000k左右的数据。清理的内存空间大反而耗时更短，看来不是这个原因，需要从其他方面分析。

2.回忆GC的步骤，串行收集器年轻代是标记-复制算法，分为标记、复制两个步骤，标记这个过程不会很耗时，而且标记耗时是跟过期对象的数量有关，这个先排除。那么问题是不是可能出在复制过程？

继续查看GC日志，发现4G的YGC虽然每次清理的内存很多，但是只剩下3，000多k的内存。1G的YGC，耗时30ms的两次GC，每次都剩下将近150,000k内存，而其余的GC（10ms以内），GC后年轻代的内存大小也是3,000k左右，和上面4G时差不多。

所以判断时间是耗在了大量的存活对象复制过程中。优化考虑略微增加年轻代大小，时间原因，还未试验。



问题2  为什么在以上测试中某些情况下并行GC的吞吐量低于串行GC？

4核以下的系统，并行不一定优于串行，压测时开的并行数量太多，系统大部分时间都花在上下文切换、锁的竞争上面。



### 2.运行GCLogAnalysis.java代码1秒钟的GC情况：

| gc       | XMX  | YGC  | YGCavg | YGCmin/max | FGC  | FGCavg | FGCmin/min | Duration | Pause Total | 对象数 | Throughput | remark                            |
| -------- | ---- | ---- | ------ | ---------- | ---- | ------ | ---------- | -------- | ----------- | ------ | ---------- | --------------------------------- |
| Serial   | 512m | 10   | 18ms   | 10/30ms    | 10   | 44ms   | 30/60ms    | 900ms    | 620ms       | 10572  | 31.111%    | Full GC - Allocation Failure：2次 |
|          | 1g   | 12   | 34.2ms | 10/50ms    | 2    | 50ms   | 40/60ms    | 860ms    | 510ms       | 14793  | 40.698%    |                                   |
|          | 4g   | 2    | 115ms  | 10/130ms   | 0    | 0ms    | 0          | 243ms    | 230ms       | 11756  | 5.36%      |                                   |
| Parallel | 512m | 23   | 6.09ms | 0/10ms     | 16   | 33.1ms | 30/40ms    | 911ms    | 670ms       | 9131   | 26.454%    |                                   |
|          | 1g   | 31   | 10ms   | 0/20ms     | 3    | 40ms   | 40/40ms    | 876ms    | 430ms       | 17441  | 50.913%    | Ergonomics :3次120ms              |
|          | 4g   | 4    | 35ms   | 30/40ms    | 0    | 0      | 0          | 462ms    | 140ms       | 17030  | 69.697%    |                                   |
| CMS      | 512m | 19   | 27.4ms | 10/50ms    | 2    | 40ms   | 30/50ms    | 943ms    | 600ms       | 11151  | 36.373%    |                                   |
|          | 1g   | 12   | 26.7ms | 40/65ms    | 2    | 45ms   | 40/50ms    | 775ms    | 410ms       | 15354  | 47.097%    |                                   |
|          | 4g   | 9    | 45.6ms | 30/50ms    | 0    | 0      | 0          | 719ms    | 410ms       | 15190  | 42.976%    |                                   |
| G1       | 512m | 44   | 1.14ms | 0/10ms     | 3    | 36.7ms | 0/40ms     | 1s12ms   | 220ms       | 11664  | 78.261%    |                                   |
|          | 1g   | 17   | 7.06ms | 0/10ms     | 7    | 1.43ms | 0/10ms     | 958ms    | 260ms       | 16790  | 72.86%     | Mixed:16次，共130ms               |
|          | 4g   | 14   | 13.6ms | 10/30ms    | 0    | 0      | 0          | 838ms    | 190ms       | 16281  | 77.327%    |                                   |



### 3.测试总结

1.以为会是最低吞吐量的串行GC，结果吞吐量意外高于其他GC。是因为压测时开的并发数太高，花在上下文切换、资源竞争的时间太多。

2.并行GC使用多个线程并发地完成GC任务，总的暂停时间、平均GC时间都要比串行GC低很多。

3.在本次测试的场景中CMS和G1的效率并不比CMS和G1的高，CMS和G1的算法要比并行和串行GC的更复杂，CMS和G1在多核CPU发服务器、内存更大一些的场景中会更占优势。





## 二、几种垃圾收集器的特点

### 1.串行垃圾收集器(Serial)

#### 	1.1 回收算法

年轻代是复制算法，老年代是标记-整理算法。

#### 	1.2特点 

使用一个单线程做所有的垃圾收集工作，在回收过程中会触发STW事件。

优点：简单高效，垃圾收集器实现的复杂度较低。

缺点：cpu利用率低，暂停时间长，

#### 	1.3 使用场景

适合单核CPU，1G以下的JVM。

### 2.并行垃圾收集器(Parllel)

#### 	2.1 回收算法

年轻代使用复制算法，老年代标记-整理。

#### 	2.2 特点

在GC过程中会触发STW事件，两次GC周期的间隔时间里，没有GC线程在运行，不会消耗系统资源；GC时所有的CPU都在清理垃圾，总暂停时间更短，可以达到更高的吞吐量。

JDK8默认使用的是并行GC。

#### 	2.3 使用场景

适合更关注于高吞吐量，对于STW时间不是非常敏感的场景。

### 3.CMS收集器(Concurrent Mark-Sweep)

#### 	3.1 回收算法

年轻代使用并行方式的复制算法ParNew，老年代使用的是并发标记清除算法。

#### 	3.2 特点

不对老年代进行整理，而是使用空闲列表来管理内存空间的回收。

在标记清除阶段的大部分工作都是和应用线程一起并发执行的。

CMS可以减少单次GC暂停时间，但吞吐量比并行GC要低一些，在CMS过程中并没有明显的应用线程暂停，但是它仍然在和应用线程争抢时间。

CMS最大的问题是老年代内存碎片问题，因为CMS是不压缩的。其次，因为CMS的算法相比并行收集器会有些复杂，所以效率并不比并行GC要高。

在默认情况下CMS使用的并发线程数等于COU核心数的1/4.

#### 	3.3 使用场景

适用于多核CPU的服务器，且对延迟敏感的场景。

### 4.G1收集器(Garbage First)

#### 	4.1 特点

G1收集器能根据运行状态来平衡停顿的时间，通过动态调整参数来达到预期目的。

G1把堆内存区域划分成若干小块，这些小块可能一会作为年轻代，一会又是老年代。

G1是以增量的方式来处理，每次只处理一部分内存块。每次GC暂停都会收集所有年轻代的内存块，一般只包含部分老年代。

在并发阶段G1会估算每个小堆块的存活数量，垃圾最多的小块会被最先收集。



#### 	4.2 使用场景

G1收集器在堆内存较大场景更加适用（比如4G 8G），因为可以通过参数来控制G1的平均收集时间。

## 三、总结

### 1.吞吐量

吞吐量=运行时间/GC总耗时。

理论上，并行收集器吞吐量最高，因为垃圾回收的任务交给多个cpu同时处理，大大缩短了单次GC的时间，串行收集器吞吐量最低，因为垃圾回收过程中全线暂停的时间略长，导致应用线程运行的时间较短。但并不完全是这样，不同的场景会有不一样的结果。

### 2.堆内存大小

并不是堆内存越大，吞吐量就越高。

堆内存过小会频繁发生GC，甚至导致OOM，虽然每次GC的暂停时间不会很长但是GC的次数增多了。

堆内存过大会增加单次GC的时间，同样会降低吞吐量。

### 3.GC如何选择

1.如果系统考虑吞吐优先，CPU资源都用来最大程度处理业务，用Parallel GC。

2.如果系统考虑低延迟优先，每次GC时间尽量短，用CMS GC。

3.如果系统内存堆较大，同时希望整体来看平均GC时间可控，使用G1 GC。

对内存大小的考量：

1.一般4G以上，算是比较大，用G1的性价比高

2.一般超过8G，非常推荐使用G1 GC。

并行GC不一定是吞吐量最高的，串行收集器也不一定是效率最低的，CMS和G1也未必GC暂停时间就更短，如何选择GC需要在具体的场景中使用几组不同的参数（不同的内存大小，不同的GC算法等等参数）去测试分析，前面的压测分析就是例子。